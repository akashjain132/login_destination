<?php
// $Id: login_destination.module,v 1.10.2.23 2010/10/27 22:12:46 setfree Exp $

/**
 * @file
 * Control where users are directed to, once they login
 */

// Condition constants
define('LOGIN_DESTINATION_REDIRECT_NOTLISTED', 0);
define('LOGIN_DESTINATION_REDIRECT_LISTED', 1);
define('LOGIN_DESTINATION_REDIRECT_PHP', 2);

// Destination constants
define('LOGIN_DESTINATION_STATIC', 0);
define('LOGIN_DESTINATION_SNIPPET', 1);

/**
 * Implement hook_help().
 */
function login_destination_help($path, $arg) {
  switch ($path) {
    case 'admin/help#login_destination':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Login Destination module allows you to specify where users are redirected to, once they login.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function login_destination_permission() {
  return array(
    'administer login destination' => array(
      'title' => t('Administer Login Destination'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function login_destination_menu() {
  $items['admin/config/people/login-redirect'] = array(
    'title' => 'Login redirects',
    'description' => 'Control where users are redirected to, once they login.',
    'page callback' => 'login_destination_overview',
    'access arguments' => array('administer login destination'),
    'file' => 'login_destination.admin.inc',
    'weight' => 10,
  );
  $items['admin/config/people/login-redirect/add'] = array(
    'title' => 'Add redirect rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('login_destination_edit_form'),
    'access arguments' => array('administer login destination'),
    'type' => MENU_LOCAL_ACTION,
    'weight' => 1,
    'file' => 'login_destination.admin.inc',
  );
  $items['admin/config/people/login-redirect/edit/%login_destination'] = array(
    'title' => 'Edit redirect rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('login_destination_edit_form', 5),
    'access arguments' => array('administer login destination'),
    'file' => 'login_destination.admin.inc',
  );
  $items['admin/config/people/login-redirect/delete/%login_destination'] = array(
    'title' => 'Delete redirect rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('login_destination_delete_form', 5),
    'access arguments' => array('administer login destination'),
    'file' => 'login_destination.admin.inc',
  );
  $items['admin/config/people/login-redirect/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  
  return $items;
}

/**
 * Load a login redirect.
 */
function login_destination_load($id) {
  $result = db_select('login_redirect', 'l')
    ->fields('l')
    ->condition('id', $id)
    ->execute()
    ->fetchAssoc();

  $result['roles'] = unserialize($result['roles']);
  if(empty($result['roles'])) {
    $result['roles'] = array();
  }

  return $result;
}

/**
 * Implements hook_theme
 */
function login_destination_theme() {
  return array(
    'login_redirect_roles' => array(
      'variables' => array('roles' => NULL),
      'file' => 'login_destination.admin.inc',
    ),
    'login_redirect_pages' => array(
      'variables' => array('pages' => NULL),
      'file' => 'login_destination.admin.inc',
    ),
  );
}

/**
 * Implements hook_form_alter
 */
function login_destination_form_alter(&$form, &$form_state, $form_id) {
  // We redirect by setting the $form_state['redirect'] variable. If we simply
  // call drupal_goto() it may break compability with other modules. If we set
  // the $_GET['destination'] variable we will loose the possibility to redirect
  // to an external URL.

  // Please note the the system_goto_action() calls drupal_goto() so it will
  // have priority over this module.
  
  // If we add the $form_state['redirect'] here it will be overriden by the
  // user_login_submit(). So we add a submit handler instead and will set the
  // redirect later. Our submit handler will be executed after the execution
  // of user_login_submit().
  switch ($form_id) {
    case 'user_login': // user login page
    case 'user_login_block': // user login block
    case 'user_login_custom': // for future use with custom login forms
        $form['#submit'][] = 'login_destination_submit';
      break;
  }
}

/**
 * Helper submit function.
 */
function login_destination_submit($form, &$form_state) {
  
  // Get all the login redirect rules from the database.
  $result = db_select('login_redirect', 'l')
    //->addTag('translatable')
    ->fields('l', array('roles', 'pages_type', 'pages', 'destination_type', 'destination'))
    ->orderBy('weight')
    ->execute()
    ->fetchAll();

  foreach ($result as $redirect_rule) {
    if (_login_destination_should_redirect($form, $form_state, $redirect_rule)) {

      $path = _login_destination_create_path($form, $form_state, $redirect_rule);

      if(!empty($path)) {
        // Insert to redirect information to form
        $form_state['redirect'] = $path;

        // check if we preserve the destination parameter
        if(!variable_get('ld_destination_preserve', FALSE)) {
          // Hack: The $_GET['destination'] from user_login_block overrides the
          // $form_state['redirect'] in drupal_goto(), so unset it.
          // More on this issue http://drupal.org/node/732542.
          unset($_GET['destination']);
        }
      }

      // match found, break
      break;
    }
  }
}

/**
 * Evaluate the code with forms context.
 *
 * This function hides the calling function's scope from eval() but
 * exposes the form variables to it. We could use the php_eval()
 * but would not be able to pass the form variables then.
 */
function _login_destination_eval($code, $form, $form_state) {
  return eval('?>' . $code);
}


/**
 * A helper function to determine whether redirection should happen.
 *
 * @return bool TRUE - apply redirect, FALSE - not to apply redirect.
 */
function _login_destination_should_redirect($form, &$form_state, $redirect_rule) {

  global $user;

  $type = $redirect_rule->pages_type;
  $pages = $redirect_rule->pages;
  $roles = unserialize($redirect_rule->roles);

  if(empty($roles))
    $roles = array();

  // examine role matches
  $role_options = array_map('check_plain', user_roles(TRUE));
  unset($role_options[DRUPAL_AUTHENTICATED_RID]);

  // remove non-existent roles
  $roles = array_intersect_key($role_options, $roles);

  $roles_intersect = array_intersect_key($roles, $user->roles);

  $role_match = (empty($roles) || !empty($roles_intersect));

  // examine path matches
  if($type < LOGIN_DESTINATION_REDIRECT_PHP) {
    $path = drupal_get_path_alias($_GET['q']);

    $page_match = drupal_match_path($path, $pages);

    if ($path != $_GET['q']) {
      $page_match = $page_match || drupal_match_path($_GET['q'], $pages);
    }
    $page_match = !($type xor $page_match);
  } 
  elseif (module_exists('php')) {
    // Expose the $form and $form_state variables to eval(). They
    // may be useful for snippets.
    $page_match = _login_destination_eval($pages, $form, &$form_state);
  }
  else {
    $page_match = FALSE;
  }

  return ($page_match && $role_match);
}

function _login_destination_create_path($form, $form_state, $redirect_rule) {
    // redirect to front by default
    $type = $redirect_rule->destination_type;
    $destination_str = $redirect_rule->destination;
    
    $path = $query = NULL;

    if($type == LOGIN_DESTINATION_STATIC) {
      // take only 1st line
      if (preg_match("!^(.*?)$!", $destination_str, $matches) === 1 ) {
        $path  = $matches[1];
      }
    }
    elseif (module_exists('php')) {

      // We cannot use the php_eval because we expect array here, but for the
      // matter of consistent UI we don't do it with the PHP Filter module off.
      // However we expose the $form and $form_state variables here which
      // are useful for snippets.
      $url = _login_destination_eval($destination_str, $form, &$form_state);

      // if an array came from the snippet (an array with "path" and "query" keys)
      if (is_array($url) && !empty($url['path'])) {
        // "/" or "/drupal/" or similar
        $base = base_path();
        global $language;
        if (!empty($language->prefix)) {
          // now becomes probably "/en/" or "/drupal/en/"
          $base .= $language->prefix . '/';
        }

        $path  = $url['path'];
        $query = $url['query'];

        // strip base from url (isn't this too paranoic?) (won't hurt)
        $path = preg_replace( "!^$base!", '', $path);
      }
      // if the snippet returned a string
      else {
        $path  = $url;
      }
    }

    // support for <front>
    if ($path == "<front>") {
      $path = drupal_get_normal_path(variable_get('site_frontpage', 'node') );
    }

    // append query
    // if external URL
    if (substr($path, 0, 4) == "http") {
      $path = trim($path, "/");
      if (!empty($query)) {
        $path .= urlencode("?" . $query);
      }
    }
    // if internal path
    else {
      if (!empty($query)) {
        $path .= "?" . $query;
      }
    }

    return $path;
}
