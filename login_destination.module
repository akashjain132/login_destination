<?php

/**
 * @file
 * Control where users are directed to, once they login
 */

// Condition constants
define('LOGIN_DESTINATION_REDIRECT_NOTLISTED', 0);
define('LOGIN_DESTINATION_REDIRECT_LISTED', 1);
define('LOGIN_DESTINATION_REDIRECT_PHP', 2);

// Destination constants
define('LOGIN_DESTINATION_STATIC', 0);
define('LOGIN_DESTINATION_SNIPPET', 1);

/**
 * Implement hook_help().
 */
function login_destination_help($path, $arg) {
  switch ($path) {
    case 'admin/help#login_destination':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Login Destination module allows you to specify where users are redirected to, once they login.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function login_destination_permission() {
  return array(
    'administer login destination' => array(
      'title' => t('Administer Login Destination'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function login_destination_menu() {

  $items['admin/config/system/login_destination'] = array(
    'title' => 'Login Destination',
    'description' => 'Control where users are redirected to, once they login.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('login_destination_admin_settings'),
    'access arguments' => array('administer login destination'),
    'file' => 'login_destination.admin.inc',
    'weight' => -10,
  );
  
  return $items;
}

/**
 * Implements hook_form_alter
 */
function login_destination_form_alter(&$form, &$form_state, $form_id) {
  // We redirect by setting the $form_state['redirect'] variable. If we simply
  // call drupal_goto() it may break compability with other modules. If we set
  // the $_GET['destination'] variable we will loose the possibility to redirect
  // to an external URL.

  // Please note the the system_goto_action() calls drupal_goto() so it will
  // have priority over this module.
  
  // If we add the $form_state['redirect'] here it will be overriden by the
  // user_login_submit(). So we add a submit handler here and will set the
  // redirect later. Our sumbit handler will be executed after the execution
  // of user_login_submit().
  switch ($form_id) {
    case 'user_login': // user login page
    case 'user_login_block': // user login block
    case 'user_login_custom': // for future use with custom login forms
        $form['#submit'][] = 'login_destination_submit';
      break;
  }
}

/**
 * Helper submit function.
 */
function login_destination_submit($form, &$form_state) {
  if (_login_destination_should_redirect($form, $form_state)) {

    $path = _login_destination_create_path($form, $form_state);

    if(!empty($path)) {
      // Insert to redirect information to form
      $form_state['redirect'] = $path;

      // check if we preserve the destination parameter
      if(!variable_get('ld_destination_preserve', FALSE)) {
        // Hack: The $_GET['destination'] from user_login_block overrides the
        // $form_state['redirect'] in drupal_goto(), so unset it.
        // More on this issue http://drupal.org/node/732542.
        unset($_GET['destination']);
      }
    }
  }
}

/**
 * Evaluate the code with forms context.
 *
 * This function hides the calling function's scope from eval() but
 * exposes the form variables to it. We could use the php_eval()
 * but would not be able to pass the form variables then.
 */
function _login_destination_eval($code, $form, $form_state) {
  return eval('?>' . $code);
}


/**
 * A helper function to determine whether redirection should happen.
 *
 * @return bool TRUE - apply redirect, FALSE - not to apply redirect.
 */
function _login_destination_should_redirect($form, &$form_state) {

  $type = variable_get('ld_condition_type', LOGIN_DESTINATION_REDIRECT_NOTLISTED);
  $pages = variable_get('ld_condition_pages', '');

  if($type < LOGIN_DESTINATION_REDIRECT_PHP) {
    $page_match = FALSE;
    $path = drupal_get_path_alias($_GET['q']);

    $page_match = drupal_match_path($path, $pages);

    if ($path != $_GET['q']) {
      $page_match = $page_match || drupal_match_path($_GET['q'], $pages);
    }
    $page_match = !($type xor $page_match);
  } 
  elseif (module_exists('php')) {
    // Expose the $form and $form_state variables to eval(). They
    // are useful for snippets.
    $page_match = _login_destination_eval($pages, $form, $form_state);
  }
  else {
    $page_match = FALSE;
  }

  return $page_match;
}

function _login_destination_create_path($form, $form_state) {
    // redirect to front by default
    $type = variable_get('ld_destination_type', LOGIN_DESTINATION_STATIC);
    $destination_str = variable_get('ld_destination_page', '<front>');
    
    $path = $query = NULL;

    if($type == LOGIN_DESTINATION_STATIC) {
      // take only 1st line
      if (preg_match("!^(.*?)$!", $destination_str, $matches) === 1 ) {
        $path  = $matches[1];
      }
    }
    elseif (module_exists('php')) {

      // We cannot use the php_eval because we expect array here, but for the
      // matter of consistent UI we don't do it with the PHP Filter module off.
      // However we expose the $form and $form_state variables here which
      // are useful for snippets.
      $url = _login_destination_eval($destination_str, $form, $form_state);

      // if an array came from the snippet (an array with "path" and "query" keys)
      if (is_array($url) && !empty($url['path'])) {
        // "/" or "/drupal/" or similar
        $base = base_path();
        global $language;
        if (!empty($language->prefix)) {
          // now becomes probably "/en/" or "/drupal/en/"
          $base .= $language->prefix . '/';
        }

        $path  = $url['path'];
        $query = $url['query'];

        // strip base from url (isn't this too paranoic?) (won't hurt)
        $path = preg_replace( "!^$base!", '', $path);
      }
      // if the snippet returned a string
      else {
        $path  = $url;
      }
    }

    // support for <front>
    if ($path == "<front>") {
      $path = drupal_get_normal_path(variable_get('site_frontpage', 'node') );
    }

    // append query
    // if external URL
    if (substr($path, 0, 4) == "http") {
      $path = trim($path, "/");
      if (!empty($query)) {
        $path .= urlencode("?" . $query);
      }
    }
    // if internal path
    else {
      if (!empty($query)) {
        $path .= "?" . $query;
      }
    }

    return $path;
}